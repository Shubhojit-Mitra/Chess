"use strict";
var sw = require("../../utils/simpleWorker");
var contract = require("./fileListingContract");
var fsu = require("../../utils/fsu");
var glob = require("glob");
var chokidar = require('chokidar');
var utils_1 = require("../../../common/utils");
var path = require('path');
var types = require("../../../common/types");
var Worker;
(function (Worker) {
    Worker.echo = function (q) {
        return exports.master.increment(q).then(function (res) {
            return {
                text: q.text,
                num: res.num
            };
        });
    };
    var directoryUnderWatch;
    Worker.setupWatch = function (q) {
        directoryUnderWatch = q.directory;
        var completed = false;
        var liveList = {};
        var sendNewFileList = function () {
            var filePaths = Object.keys(liveList)
                .filter(function (x) { return !x.includes('/.git/'); })
                .sort(function (a, b) {
                if (b.startsWith(a)) {
                    return -1;
                }
                if (a.startsWith(b)) {
                    return 1;
                }
                if (!completed) {
                    return a.length - b.length;
                }
                return a.toLowerCase().localeCompare(b.toLowerCase());
            })
                .map(function (filePath) {
                var type = liveList[filePath];
                return { filePath: filePath, type: type };
            });
            exports.master.fileListUpdated({
                filePaths: filePaths,
                completed: completed
            });
        };
        var sendNewFileListThrottled = utils_1.throttle(sendNewFileList, 500);
        (function () {
            var mg = new glob.Glob('**', { cwd: q.directory }, function (e, newList) {
                if (e) {
                    console.error('Globbing error:', e);
                }
                var list = newList.map(function (nl) {
                    var p = path.resolve(q.directory, nl);
                    var type = mg.cache[p] && mg.cache[p] == 'FILE' ? types.FilePathType.File : types.FilePathType.Dir;
                    return {
                        filePath: fsu.consistentPath(p),
                        type: type,
                    };
                });
                completed = true;
                list.forEach(function (entry) { return liveList[entry.filePath] = entry.type; });
                sendNewFileList();
            });
            mg.on('match', function (match) {
                var p = path.resolve(q.directory, match);
                if (mg.cache[p]) {
                    liveList[fsu.consistentPath(p)] = mg.cache[p] == 'FILE' ? types.FilePathType.File : types.FilePathType.Dir;
                    sendNewFileListThrottled();
                }
            });
        })();
        function fileAdded(filePath, stat) {
            filePath = fsu.consistentPath(filePath);
            if (!liveList[filePath]) {
                var type = stat && stat.isDirectory() ? types.FilePathType.Dir : types.FilePathType.File;
                liveList[filePath] = type;
                sendNewFileListThrottled();
            }
        }
        function fileDeleted(filePath) {
            filePath = fsu.consistentPath(filePath);
            delete liveList[filePath];
            sendNewFileListThrottled();
        }
        var watcher = chokidar.watch(directoryUnderWatch, { ignoreInitial: true });
        watcher.on('add', fileAdded);
        watcher.on('unlink', fileDeleted);
        watcher.on('change', function (filePath, stat) {
            filePath = fsu.consistentPath(filePath);
            var type = stat && stat.isDirectory() ? types.FilePathType.Dir : types.FilePathType.File;
            exports.master.fileChanged({ filePath: filePath, type: type });
        });
        return Promise.resolve({});
    };
})(Worker || (Worker = {}));
var _checkTypes = Worker;
exports.master = sw.runWorker(Worker, contract.master).master;
