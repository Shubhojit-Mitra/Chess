"use strict";
var utils = require("../../common/utils");
var flm = require("../workers/fileListing/fileListingMaster");
var fmc = require("../disk/fileModelCache");
var tsconfig = require("./core/tsconfig");
var types = require("../../common/types");
var errorsCache_1 = require("./errorsCache");
var building_1 = require("./building");
var utils_1 = require("../../common/utils");
var events_1 = require("../../common/events");
var session = require("../disk/session");
var workingDir = require("../disk/workingDir");
var activeProjectConfigDetails = null;
exports.activeProjectConfigDetailsUpdated = new events_1.TypedEvent();
var implicitProjectName = "__auto__";
var currentProject = null;
exports.availableProjects = new events_1.TypedEvent();
function refreshAvailableProjects() {
    return flm.filePathsCompleted.current().then(function (list) {
        var tsconfigs = list.filePaths.map(function (t) { return t.filePath; }).filter(function (t) { return t.endsWith('tsconfig.json'); });
        var weightConfig = function (config) { return config.includes('node_modules') ? config.length + 100 : config.length; };
        tsconfigs = tsconfigs.sort(function (a, b) {
            return weightConfig(a) - weightConfig(b);
        });
        var projectConfigs = tsconfigs.map(Utils.tsconfigToActiveProjectConfigDetails);
        if (projectConfigs.length == 0) {
            projectConfigs.push({
                name: implicitProjectName,
                isImplicit: true,
            });
        }
        ;
        exports.availableProjects.emit(projectConfigs);
    });
}
function start() {
    exports.activeProjectConfigDetailsUpdated.on(function (ap) {
        if (ap.tsconfigFilePath) {
            session.setTsconfigPath(ap.tsconfigFilePath);
        }
    });
    var ses = session.getDefaultOrNewSession();
    if (ses.relativePathToTsconfig) {
        var tsconfig_1 = workingDir.makeAbsolute(ses.relativePathToTsconfig);
        if (fs.existsSync(tsconfig_1)) {
            activeProjectConfigDetails = Utils.tsconfigToActiveProjectConfigDetails(tsconfig_1);
            exports.activeProjectConfigDetailsUpdated.emit(activeProjectConfigDetails);
        }
    }
    refreshAvailableProjects()
        .then(function () { return sync(); });
}
exports.start = start;
function setActiveProjectConfigDetails(_activeProjectConfigDetails) {
    activeProjectConfigDetails = _activeProjectConfigDetails;
    exports.activeProjectConfigDetailsUpdated.emit(activeProjectConfigDetails);
    errorsCache_1.clearErrors();
    sync();
}
exports.setActiveProjectConfigDetails = setActiveProjectConfigDetails;
function sync() {
    exports.availableProjects.current().then(function (projectConfigs) {
        var activeProjectName = (activeProjectConfigDetails && activeProjectConfigDetails.name);
        var projectConfig = projectConfigs.filter(function (x) { return x.name == activeProjectName; })[0] || projectConfigs[0];
        currentProject = null;
        var configFileDetails = ConfigFile.getConfigFileFromDiskOrInMemory(projectConfig);
        currentProject = ConfigFile.createProjectFromConfigFile(configFileDetails);
        if (!projectConfig.isImplicit) {
            errorsCache_1.clearErrorsForFilePath(projectConfig.tsconfigFilePath);
        }
        if (activeProjectName !== projectConfig.name) {
            activeProjectConfigDetails = projectConfig;
            exports.activeProjectConfigDetailsUpdated.emit(activeProjectConfigDetails);
        }
        refreshAllProjectDiagnostics();
    });
}
exports.sync = sync;
flm.filePathsCompleted.on(function (data) {
    refreshAvailableProjects();
});
fmc.savedFileChangedOnDisk.on(function (evt) {
    var proj = GetProject.ifCurrent(evt.filePath);
    if (proj) {
        proj.languageServiceHost.updateScript(evt.filePath, evt.contents);
        refreshAllProjectDiagnostics();
    }
});
fmc.didEdit.on(function (evt) {
    var proj = GetProject.ifCurrent(evt.filePath);
    if (proj) {
        proj.languageServiceHost.editScript(evt.filePath, evt.edit.from, evt.edit.to, evt.edit.newText);
        if (evt.edit.from.line < 1000) {
            refreshFileDiagnostics(evt.filePath);
        }
        refreshAllProjectDiagnostics();
    }
    var currentConfigFilePath = activeProjectConfigDetails && activeProjectConfigDetails.tsconfigFilePath;
    if (evt.filePath == currentConfigFilePath) {
        sync();
    }
});
var refreshAllProjectDiagnostics = utils.debounce(function () {
    if (currentProject) {
        var diagnostics = currentProject.getDiagnostics();
        var errors = diagnostics.map(building_1.diagnosticToCodeError);
        var filePaths = currentProject.getProjectSourceFiles().map(function (x) { return x.fileName; });
        errorsCache_1.setErrorsByFilePaths(filePaths, errors);
    }
}, 3000);
var refreshFileDiagnostics = utils.debounce(function (filePath) {
    var proj = GetProject.ifCurrent(filePath);
    if (proj) {
        var diagnostics = proj.getDiagnosticsForFile(filePath);
        var errors = diagnostics.map(building_1.diagnosticToCodeError);
        errorsCache_1.setErrorsByFilePaths([filePath], errors);
    }
}, 1000);
var fs = require("fs");
var path = require("path");
var project_1 = require("./core/project");
var fileModelCache_1 = require("../disk/fileModelCache");
var ConfigFile;
(function (ConfigFile) {
    function createProjectFromConfigFile(configFile) {
        var project = new project_1.Project(configFile);
        fileModelCache_1.getOpenFiles().forEach(function (fileModel) {
            if (project.includesSourceFile(fileModel.config.filePath)) {
                project.languageServiceHost.updateScript(fileModel.config.filePath, fileModel.getContents());
            }
        });
        return project;
    }
    ConfigFile.createProjectFromConfigFile = createProjectFromConfigFile;
    function reportProjectFileErrors(ex, filePath) {
        var err = ex;
        if (ex.message === tsconfig.errors.GET_PROJECT_JSON_PARSE_FAILED
            || ex.message === tsconfig.errors.GET_PROJECT_PROJECT_FILE_INVALID_OPTIONS
            || ex.message === tsconfig.errors.GET_PROJECT_GLOB_EXPAND_FAILED) {
            var details = ex.details;
            errorsCache_1.setErrorsByFilePaths([filePath], [details.error]);
        }
        else {
            errorsCache_1.setErrorsByFilePaths([filePath], [utils_1.makeBlandError(filePath, "" + ex.message)]);
        }
    }
    function getConfigFileFromDiskOrInMemory(config) {
        if (!config.tsconfigFilePath) {
            return tsconfig.getDefaultInMemoryProject(process.cwd());
        }
        else {
            var filePath = config.tsconfigFilePath;
        }
        try {
            if (path.dirname(filePath) == project_1.languageServiceHost.typescriptDirectory) {
                return tsconfig.getDefaultInMemoryProject(filePath);
            }
            var projectFile = tsconfig.getProjectSync(filePath);
            errorsCache_1.clearErrorsForFilePath(projectFile.projectFilePath);
            return projectFile;
        }
        catch (ex) {
            if (ex.message === tsconfig.errors.GET_PROJECT_NO_PROJECT_FOUND) {
                if (tsconfig.endsWith(filePath.toLowerCase(), '.d.ts')) {
                    return tsconfig.getDefaultInMemoryProject(filePath);
                }
                else {
                    errorsCache_1.setErrorsByFilePaths([filePath], [utils_1.makeBlandError(filePath, 'No project file found')]);
                    throw ex;
                }
            }
            else {
                reportProjectFileErrors(ex, filePath);
                throw ex;
            }
        }
    }
    ConfigFile.getConfigFileFromDiskOrInMemory = getConfigFileFromDiskOrInMemory;
})(ConfigFile || (ConfigFile = {}));
var GetProject;
(function (GetProject) {
    function ifCurrent(filePath) {
        if (currentProject && currentProject.includesSourceFile(filePath)) {
            return currentProject;
        }
    }
    GetProject.ifCurrent = ifCurrent;
    function ifCurrentOrErrorOut(filePath) {
        var proj = ifCurrent(filePath);
        if (!proj) {
            console.error(types.errors.CALLED_WHEN_NO_ACTIVE_PROJECT_FOR_FILE_PATH, filePath);
            throw new Error(types.errors.CALLED_WHEN_NO_ACTIVE_PROJECT_FOR_FILE_PATH);
        }
        return proj;
    }
    GetProject.ifCurrentOrErrorOut = ifCurrentOrErrorOut;
    function allFilePaths() {
        if (currentProject) {
            return currentProject.getProjectSourceFiles().map(function (x) { return x.fileName; });
        }
        return [];
    }
    GetProject.allFilePaths = allFilePaths;
})(GetProject = exports.GetProject || (exports.GetProject = {}));
var Utils;
(function (Utils) {
    function tsconfigToActiveProjectConfigDetails(tsconfig) {
        var relative = workingDir.makeRelative(tsconfig);
        var isNodeModule = relative.includes('node_modules');
        return {
            name: isNodeModule ? relative : utils.getDirectoryAndFileName(tsconfig),
            isImplicit: false,
            tsconfigFilePath: tsconfig
        };
    }
    Utils.tsconfigToActiveProjectConfigDetails = tsconfigToActiveProjectConfigDetails;
})(Utils || (Utils = {}));
