"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var types = require("../common/types");
var React = require("react");
var csx = require('csx');
var ui_1 = require("./ui");
var ui = require("./ui");
var utils = require("../common/utils");
var state = require("./state/state");
var react_redux_1 = require("react-redux");
var icon_1 = require("./icon");
var commands = require("./commands/commands");
var DraggableCore = ui.DraggableCore;
var utils_1 = require("../common/utils");
var robocop_1 = require("./robocop");
var Mousetrap = require("mousetrap");
var dirSelected = { isDir: true };
var fileSelected = { isDir: false };
var resizerWidth = 5;
var resizerStyle = {
    background: 'radial-gradient(#444,transparent)',
    width: resizerWidth + 'px',
    cursor: 'ew-resize',
    color: '#666',
};
var treeListStyle = {
    background: '#333',
    color: '#eee',
    fontSize: '.8rem',
    padding: '5px',
    overflow: 'auto'
};
var treeItemStyle = {
    whiteSpace: 'nowrap',
    cursor: 'pointer',
    padding: '3px',
    userSelect: 'none',
};
var treeItemSelectedStyle = {
    backgroundColor: '#444',
};
var FileTree = (function (_super) {
    __extends(FileTree, _super);
    function FileTree(props) {
        var _this = this;
        _super.call(this, props);
        this.dirLookup = {};
        this.refNames = { treeRootNode: '1' };
        this.handleDrag = function (evt, ui) {
            _this.setState({ width: ui.position.clientX + resizerWidth });
        };
        this.handleStop = function () {
        };
        this.setupTree = function (props) {
            var filePaths = props.filePaths.filter(function (fp) { return fp.type == types.FilePathType.File; }).map(function (fp) { return fp.filePath; });
            if (!filePaths.length) {
                return;
            }
            var rootDirPath = utils.getDirectory(filePaths[0]);
            var rootDir = {
                name: utils.getFileName(rootDirPath),
                filePath: rootDirPath,
                subDirs: [],
                files: []
            };
            _this.state.expansionState[rootDirPath] = true;
            _this.dirLookup = {};
            _this.dirLookup[rootDirPath] = rootDir;
            var _loop_1 = function(filePath) {
                var dir = utils_1.getDirectory(filePath);
                var fileName = utils_1.getFileName(filePath);
                var subItem = {
                    name: fileName,
                    filePath: filePath,
                };
                var createDirAndMakeSureAllParentExits = function (dir) {
                    var dirTree = {
                        name: utils_1.getFileName(dir),
                        filePath: dir,
                        subDirs: [],
                        files: []
                    };
                    _this.dirLookup[dir] = dirTree;
                    var parentDir = utils_1.getDirectory(dir);
                    var parentDirTree = _this.dirLookup[parentDir];
                    if (!parentDirTree) {
                        parentDirTree = createDirAndMakeSureAllParentExits(parentDir);
                    }
                    parentDirTree.subDirs.push(dirTree);
                    return dirTree;
                };
                var treeDir = _this.dirLookup[dir];
                if (!treeDir) {
                    treeDir = createDirAndMakeSureAllParentExits(dir);
                }
                treeDir.files.push(subItem);
            };
            for (var _i = 0, filePaths_1 = filePaths; _i < filePaths_1.length; _i++) {
                var filePath = filePaths_1[_i];
                _loop_1(filePath);
            }
            _this.setState({ treeRoot: rootDir, expansionState: _this.state.expansionState });
        };
        this.handleToggleDir = function (evt, item) {
            evt.stopPropagation();
            var dirPath = item.filePath;
            _this.state.selectedPaths = {};
            _this.state.selectedPaths[dirPath] = dirSelected;
            _this.state.expansionState[dirPath] = !_this.state.expansionState[dirPath];
            _this.setState({ expansionState: _this.state.expansionState, selectedPaths: _this.state.selectedPaths });
        };
        this.handleSelectFile = function (evt, item) {
            evt.stopPropagation();
            var filePath = item.filePath;
            _this.state.selectedPaths = {};
            _this.state.selectedPaths[filePath] = fileSelected;
            _this.setState({ selectedPaths: _this.state.selectedPaths });
            commands.doOpenOrFocusFile.emit({ filePath: filePath });
        };
        this.state = {
            width: 200,
            shown: false,
            expansionState: {},
            selectedPaths: {},
            treeRoot: { name: 'loading', filePath: 'loading', subDirs: [], files: [] }
        };
        this.setupTree(props);
    }
    FileTree.prototype.componentWillReceiveProps = function (props) {
        this.setupTree(props);
    };
    FileTree.prototype.componentDidMount = function () {
        var _this = this;
        var handleFocusRequestBasic = function () {
            var selectedFilePaths = Object.keys(_this.state.selectedPaths);
            var pathToFocus = selectedFilePaths.length > 0
                ? selectedFilePaths[selectedFilePaths.length - 1]
                : _this.state.treeRoot.filePath;
            _this.ref(pathToFocus).focus();
            return false;
        };
        this.disposible.add(commands.treeViewToggle.on(function () {
            _this.setState({ shown: !_this.state.shown });
            if (_this.state.shown) {
                handleFocusRequestBasic();
            }
            else {
                commands.esc.emit({});
            }
        }));
        this.disposible.add(commands.treeViewRevealActiveFile.on(function () {
            if (!_this.state.shown) {
                _this.setState({ shown: true });
            }
            var selectedTab = state.getSelectedTab();
            if (selectedTab && selectedTab.url.startsWith('file://')) {
                var filePath = utils.getFilePathFromUrl(selectedTab.url);
                var root = _this.state.treeRoot.filePath;
                var remainderAfterRoot = filePath.substr(root.length + 1);
                var dirPortionsAfterRoot = utils.getDirectory(remainderAfterRoot).split('/');
                var runningPortion = '';
                var expanded = {};
                expanded[root] = true;
                for (var _i = 0, dirPortionsAfterRoot_1 = dirPortionsAfterRoot; _i < dirPortionsAfterRoot_1.length; _i++) {
                    var portion = dirPortionsAfterRoot_1[_i];
                    runningPortion = runningPortion + '/' + portion;
                    var fullPath = root + runningPortion;
                    expanded[fullPath] = true;
                }
                var expansionState = csx.extend(_this.state.expansionState, expanded);
                var selectedPaths = {};
                selectedPaths[filePath] = fileSelected;
                _this.setState({ expansionState: expansionState, selectedPaths: selectedPaths });
                _this.ref(filePath).focus();
            }
            else {
                handleFocusRequestBasic();
            }
            return false;
        }));
        this.disposible.add(commands.treeViewFocus.on(function () {
            handleFocusRequestBasic();
        }));
        var goDownToSmallestSelection = function () {
            var selectedFilePaths = Object.keys(_this.state.selectedPaths);
            if (selectedFilePaths.length == 0) {
                var selectedPaths = {};
                selectedPaths[_this.state.treeRoot.filePath] = dirSelected;
                _this.setState({ selectedPaths: selectedPaths });
            }
            else if (selectedFilePaths.length > 1) {
                var selectedPaths = {};
                var path = selectedFilePaths[selectedFilePaths.length - 1];
                selectedPaths[path] = _this.state.selectedPaths[path];
                _this.setState({ selectedPaths: selectedPaths });
            }
            else {
            }
            var selectedFilePath = Object.keys(_this.state.selectedPaths)[0];
            var selectedFilePathDetails = _this.state.selectedPaths[selectedFilePath];
            return { selectedFilePath: selectedFilePath, isDir: selectedFilePathDetails.isDir };
        };
        var setAsOnlySelected = function (filePath, isDir) {
            var selectedPaths = {};
            selectedPaths[filePath] = { isDir: isDir };
            _this.setState({ selectedPaths: selectedPaths });
            _this.ref(filePath).focus();
        };
        var treeRoot = this.ref(this.refNames.treeRootNode);
        var handlers = new Mousetrap(treeRoot);
        handlers.bind(commands.treeAddFile.config.keyboardShortcut, function () {
            console.log('add File');
            return false;
        });
        handlers.bind(commands.treeDuplicateFile.config.keyboardShortcut, function () {
            console.log('duplicate File');
            return false;
        });
        handlers.bind(commands.treeMoveFile.config.keyboardShortcut, function () {
            console.log('move File');
            return false;
        });
        handlers.bind([commands.treeDeleteFile.config.keyboardShortcut, "backspace"], function () {
            console.log('delete File');
            return false;
        });
        handlers.bind('up', function () {
            var _a = goDownToSmallestSelection(), selectedFilePath = _a.selectedFilePath, isDir = _a.isDir;
            if (selectedFilePath == _this.state.treeRoot.filePath) {
                return;
            }
            var parentDirFilePath = utils.getDirectory(selectedFilePath);
            var parentDirTreeItem = _this.dirLookup[parentDirFilePath];
            var indexInParentDir = isDir
                ? parentDirTreeItem.subDirs.map(function (x) { return x.filePath; }).indexOf(selectedFilePath)
                : parentDirTreeItem.files.map(function (x) { return x.filePath; }).indexOf(selectedFilePath);
            var gotoBottomOfFolder = function (closestDir) {
                while (true) {
                    if (!_this.state.expansionState[closestDir.filePath]) {
                        setAsOnlySelected(closestDir.filePath, true);
                        break;
                    }
                    if (closestDir.files.length) {
                        setAsOnlySelected(closestDir.files[closestDir.files.length - 1].filePath, false);
                        break;
                    }
                    else if (closestDir.subDirs.length) {
                        closestDir = closestDir.subDirs[closestDir.subDirs.length - 1];
                        continue;
                    }
                    else {
                        setAsOnlySelected(closestDir.filePath, true);
                        break;
                    }
                }
            };
            if (indexInParentDir == 0) {
                if (isDir) {
                    setAsOnlySelected(parentDirFilePath, true);
                }
                else if (parentDirTreeItem.subDirs.length == 0) {
                    setAsOnlySelected(parentDirFilePath, true);
                }
                else {
                    gotoBottomOfFolder(parentDirTreeItem.subDirs[parentDirTreeItem.subDirs.length - 1]);
                }
            }
            else if (!isDir) {
                setAsOnlySelected(parentDirTreeItem.files[indexInParentDir - 1].filePath, false);
            }
            else {
                var closestDir = parentDirTreeItem.subDirs[indexInParentDir - 1];
                gotoBottomOfFolder(closestDir);
            }
            return false;
        });
        handlers.bind('down', function () {
            var _a = goDownToSmallestSelection(), selectedFilePath = _a.selectedFilePath, isDir = _a.isDir;
            var gotoNextSiblingHighUp = function (treeItem) {
                if (treeItem.filePath == _this.state.treeRoot.filePath) {
                    return;
                }
                var parentDirFilePath = utils.getDirectory(treeItem.filePath);
                var parentTreeItem = _this.dirLookup[parentDirFilePath];
                var indexInParent = parentTreeItem.subDirs.map(function (x) { return x.filePath; }).indexOf(treeItem.filePath);
                if (indexInParent !== (parentTreeItem.subDirs.length - 1)) {
                    setAsOnlySelected(parentTreeItem.subDirs[indexInParent + 1].filePath, true);
                }
                else if (parentTreeItem.files.length) {
                    setAsOnlySelected(parentTreeItem.files[0].filePath, false);
                }
                else {
                    gotoNextSiblingHighUp(parentTreeItem);
                }
            };
            if (isDir) {
                var dirTreeItem = _this.dirLookup[selectedFilePath];
                if (_this.state.expansionState[selectedFilePath]
                    && (dirTreeItem.files.length || dirTreeItem.subDirs.length)) {
                    dirTreeItem.subDirs[0]
                        ? setAsOnlySelected(dirTreeItem.subDirs[0].filePath, true)
                        : setAsOnlySelected(dirTreeItem.files[0].filePath, false);
                }
                else {
                    gotoNextSiblingHighUp(dirTreeItem);
                }
            }
            else {
                var parentDirFilePath = utils.getDirectory(selectedFilePath);
                var parentTreeItem = _this.dirLookup[parentDirFilePath];
                var indexInParent = parentTreeItem.files.map(function (f) { return f.filePath; }).indexOf(selectedFilePath);
                if (indexInParent !== (parentTreeItem.files.length - 1)) {
                    setAsOnlySelected(parentTreeItem.files[indexInParent + 1].filePath, false);
                }
                else {
                    gotoNextSiblingHighUp(parentTreeItem);
                }
            }
            return false;
        });
        handlers.bind('left', function () {
            var _a = goDownToSmallestSelection(), selectedFilePath = _a.selectedFilePath, isDir = _a.isDir;
            if (isDir) {
                if (_this.state.expansionState[selectedFilePath]) {
                    delete _this.state.expansionState[selectedFilePath];
                    _this.setState({ expansionState: _this.state.expansionState });
                    return;
                }
                if (_this.state.treeRoot.filePath == selectedFilePath) {
                    return;
                }
            }
            setAsOnlySelected(utils.getDirectory(selectedFilePath), true);
            return false;
        });
        handlers.bind('right', function () {
            var _a = goDownToSmallestSelection(), selectedFilePath = _a.selectedFilePath, isDir = _a.isDir;
            if (isDir) {
                _this.state.expansionState[selectedFilePath] = true;
                _this.setState({ expansionState: _this.state.expansionState });
                return;
            }
            return false;
        });
    };
    FileTree.prototype.render = function () {
        var singlePathSelected = Object.keys(this.state.selectedPaths).length == 1
            && Object.keys(this.state.selectedPaths)[0];
        var hideStyle = !this.state.shown && { display: 'none' };
        return (React.createElement("div", {ref: this.refNames.treeRootNode, style: [csx.flexRoot, csx.horizontal, { width: this.state.width }, hideStyle]}, React.createElement("div", {style: [csx.flex, csx.vertical, treeListStyle]}, this.props.filePathsCompleted || React.createElement(robocop_1.Robocop, null), this.renderDir(this.state.treeRoot)), React.createElement(DraggableCore, {onDrag: this.handleDrag, onStop: this.handleStop}, React.createElement("div", {style: [csx.flexRoot, csx.centerCenter, resizerStyle]}, React.createElement(icon_1.Icon, {name: "ellipsis-v"})))));
    };
    FileTree.prototype.renderDir = function (item, depth) {
        var _this = this;
        if (depth === void 0) { depth = 0; }
        var expanded = this.state.expansionState[item.filePath];
        var icon = expanded ? 'folder-open' : 'folder';
        var sub = expanded ? this.renderDirSub(item, depth) : [];
        var selectedStyle = this.state.selectedPaths[item.filePath] ? treeItemSelectedStyle : {};
        return ([React.createElement("div", {style: [treeItemStyle, selectedStyle], key: item.filePath, ref: item.filePath, tabIndex: -1, onClick: function (evt) { return _this.handleToggleDir(evt, item); }}, ui.indent(depth, 2), " ", React.createElement(icon_1.Icon, {name: icon}), " ", item.name)].concat(sub));
    };
    FileTree.prototype.renderDirSub = function (item, depth) {
        var _this = this;
        return item.subDirs.map(function (item) { return _this.renderDir(item, depth + 1); })
            .concat(item.files.map(function (file) { return _this.renderFile(file, depth + 1); }));
    };
    FileTree.prototype.renderFile = function (item, depth) {
        var _this = this;
        var selectedStyle = this.state.selectedPaths[item.filePath] ? treeItemSelectedStyle : {};
        return (React.createElement("div", {style: [treeItemStyle, selectedStyle], key: item.filePath, ref: item.filePath, tabIndex: -1, onClick: function (evt) { return _this.handleSelectFile(evt, item); }}, ui.indent(depth, 2), " ", React.createElement(icon_1.Icon, {name: "file-text-o"}), " ", item.name));
    };
    FileTree = __decorate([
        react_redux_1.connect(function (state) {
            return {
                filePaths: state.filePaths,
                filePathsCompleted: state.filePathsCompleted,
            };
        }),
        ui.Radium, 
        __metadata('design:paramtypes', [Object])
    ], FileTree);
    return FileTree;
})(ui_1.BaseComponent);
exports.FileTree = FileTree;
