"use strict";
var React = require("react");
var ReactDOM = require("react-dom");
var utils = require("../../../common/utils");
var commands = require("../../commands/commands");
var CodeMirror = require('codemirror');
require('./jumpy.css');
var lowerCharacters = [];
for (var i = 'a'.charCodeAt(0); i < 'z'.charCodeAt(0); i++) {
    lowerCharacters.push(String.fromCharCode(i));
}
var keys = [];
for (var _i = 0, lowerCharacters_1 = lowerCharacters; _i < lowerCharacters_1.length; _i++) {
    var c1 = lowerCharacters_1[_i];
    for (var _a = 0, lowerCharacters_2 = lowerCharacters; _a < lowerCharacters_2.length; _a++) {
        var c2 = lowerCharacters_2[_a];
        keys.push(c1 + c2);
    }
}
function getState(cm) {
    return cm.state.jumpy || (cm.state.jumpy = { widgets: [], shown: false });
}
exports.getState = getState;
function createOverlays(cm) {
    var doc = cm.getDoc();
    var _a = cm.getViewport(), from = _a.from, to = _a.to;
    var text = cm.getDoc().getRange({ line: from, ch: 0 }, { line: to, ch: 0 });
    var splitRegex = /^[A-Z]?[0-9a-z]+|^[\{\};]+/;
    var scrollInfo = cm.getScrollInfo();
    var topLine = cm.coordsChar({ top: scrollInfo.top, left: scrollInfo.left }, 'local').line;
    var bottomLine = cm.coordsChar({ top: scrollInfo.top + scrollInfo.clientHeight, left: scrollInfo.left }, 'local').line + 1;
    var lines = [];
    for (var i = 0; i < bottomLine - topLine; i++) {
        lines.push(i);
    }
    var keysIndex = 0;
    var overlayByLines = utils.selectMany(lines.map(function (x) {
        var trueLine = x + topLine;
        var string = doc.getLine(trueLine);
        var pos = 0;
        var lineOverlays = [];
        while (pos !== string.length) {
            var matches = /^[A-Z]?[0-9a-z]+|^[\{\};]+/.exec(string.substr(pos));
            if (matches && matches.length) {
                var matched = matches[0];
                var name_1 = keys[keysIndex++];
                var nodeRendered = React.createElement("div", {key: x + ':' + pos, className: "cm-jumpy", style: { top: '-1rem' }}, name_1);
                var node = document.createElement('div');
                ReactDOM.render(nodeRendered, node);
                var widget = {
                    node: node,
                    line: trueLine,
                    ch: pos,
                    keys: name_1,
                };
                lineOverlays.push(widget);
                pos += matched.length;
            }
            else {
                pos++;
            }
        }
        return lineOverlays;
    }));
    overlayByLines.forEach(function (wg) { return cm.addWidget({ line: wg.line, ch: wg.ch }, wg.node, false); });
    var state = getState(cm);
    state.widgets = overlayByLines;
    state.shown = true;
}
function clearAnyOverlay(cm) {
    var state = getState(cm);
    if (state.shown) {
        state.widgets.forEach(function (wg) { return wg.node.parentElement.removeChild(wg.node); });
        state.widgets = [];
        state.key1 = null;
        state.key2 = null;
        state.shown = false;
        cm.off('beforeChange', handleBeforeChange);
        cm.off('scroll', clearAnyOverlay);
    }
}
function addOverlay(cm) {
    clearAnyOverlay(cm);
    createOverlays(cm);
    commands.esc.once(function () {
        clearAnyOverlay(cm);
    });
    cm.on('beforeChange', handleBeforeChange);
    cm.on('scroll', clearAnyOverlay);
}
function handleBeforeChange(cm, changeObj) {
    changeObj.cancel();
    var state = getState(cm);
    if (!state.key1) {
        state.key1 = changeObj.text;
        setTimeout(function () {
            state.widgets.filter(function (wg) { return !wg.keys.startsWith(state.key1); }).forEach(function (wg) { return wg.node.parentElement.removeChild(wg.node); });
            state.widgets = state.widgets.filter(function (wg) { return wg.keys.startsWith(state.key1); });
            if (state.widgets.length == 0) {
                clearAnyOverlay(cm);
            }
        });
    }
    else {
        setTimeout(function () {
            var total = state.key1 + changeObj.text;
            var matched = state.widgets.find(function (wg) { return wg.keys == total; });
            if (matched) {
                cm.getDoc().setCursor({ line: matched.line, ch: matched.ch });
            }
            clearAnyOverlay(cm);
        });
    }
}
CodeMirror.commands[commands.additionalEditorCommands.jumpy] = function (cm) {
    var doc = cm.getDoc();
    var cursor = cm.getDoc().getCursor();
    var filePath = cm.filePath;
    var position = cm.getDoc().indexFromPos(cursor);
    doc.setSelection(cursor, cursor);
    addOverlay(cm);
};
