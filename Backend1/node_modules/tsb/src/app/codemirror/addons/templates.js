"use strict";
require("./templates.css");
var CodeMirror = require('codemirror');
var Pos = CodeMirror.Pos;
var templatesMap = {};
function startsWith(str, token) {
    return str.slice(0, token.length).toUpperCase() == token.toUpperCase();
}
function getLabel(proposal) {
    var template = proposal.template;
    return document.createTextNode(template.name);
}
var ourMap = {
    Tab: selectNextVariable,
    Enter: function (cm) { selectNextVariable(cm, true); },
    Esc: uninstall
};
var TemplateState = (function () {
    function TemplateState() {
        this.marked = [];
        this.selectableMarkers = [];
        this.varIndex = -1;
    }
    return TemplateState;
})();
function getState(cm) {
    return (cm._templateState);
}
function setState(cm, state) {
    cm._templateState = state;
}
function goIntoInsertMode(cm) {
    if (getState(cm)) {
        uninstall(cm);
    }
    var state = new TemplateState();
    setState(cm, state);
    return state;
}
var Template = (function () {
    function Template(data) {
        var _this = this;
        this.tokens = function () {
            if (_this._tokens == null) {
                _this._tokens = parseTemplate(_this.source);
            }
            return _this._tokens;
        };
        this.content = function () {
            if (_this._content == null) {
                var tokens = _this.tokens();
                var content = '';
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (typeof token === 'string') {
                        content += token;
                    }
                    else if (token.variable) {
                        content += token.variable.name;
                    }
                    else {
                    }
                }
                _this._content = content;
            }
            return _this._content;
        };
        this.insert = function (cm, data) {
            var state = goIntoInsertMode(cm);
            var tokens = _this.tokens();
            var content = '';
            var line = data.from.line;
            var col = data.from.ch;
            var markers = [];
            var variableHasBeenAdded = {};
            var cursor = null;
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (typeof token === 'string') {
                    content += token;
                    if (token == "\n") {
                        line++;
                        col = 0;
                    }
                    else {
                        col += token.length;
                    }
                }
                else if (token.variable) {
                    content += token.variable.name;
                    var from = Pos(line, col);
                    var to = Pos(line, col
                        + token.variable.name.length);
                    var selectable = !variableHasBeenAdded[token.variable.name];
                    col += token.variable.name.length;
                    markers.push({
                        from: from,
                        to: to,
                        variable: token.variable.name,
                        selectable: selectable
                    });
                    variableHasBeenAdded[token.variable.name] = true;
                }
                else if (token.cursor) {
                    cursor = Pos(line, col);
                }
                else {
                }
            }
            var from = data.from;
            var to = data.to;
            var startLine = from.line;
            cm.getDoc().replaceRange(content, from, to);
            for (var i = 0; i < markers.length; i++) {
                var marker = markers[i], from = marker.from, to = marker.to;
                var markText = cm.getDoc().markText(from, to, {
                    className: "CodeMirror-templates-variable",
                    startStyle: "CodeMirror-templates-variable-start",
                    endStyle: "CodeMirror-templates-variable-end",
                    inclusiveLeft: true,
                    inclusiveRight: true,
                    clearWhenEmpty: false,
                    _templateVar: marker.variable
                });
                state.marked.push(markText);
                if (marker.selectable == true) {
                    state.selectableMarkers.push(markText);
                }
            }
            if (cursor != null) {
                state.cursor = cm.getDoc().setBookmark(cursor);
            }
            var lines = content.split("\n");
            for (var x = 1; x < lines.length; x++) {
                var targetLine = startLine + x;
                cm.indentLine(targetLine);
            }
            cm.on("change", onChange);
            cm.addKeyMap(ourMap);
            selectNextVariable(cm, true);
        };
        this.name = data.name;
        this.description = data.description;
        if (data.template != null) {
            this.source = data.template;
        }
        else if (data.tokens != null) {
            this._tokens = data.tokens;
        }
    }
    return Template;
})();
function parseTemplate(content) {
    var tokens = [];
    var varParsing = false;
    var last = null;
    var token = '';
    var lastVariableIndex = 0;
    for (var i = 0; i < content.length; i++) {
        var current = content.charAt(i);
        if (current == "\n") {
            if (token != '') {
                tokens.push(token);
            }
            token = '';
            tokens.push(current);
            last = null;
        }
        else {
            var addChar = true;
            if (varParsing) {
                if (current == "}") {
                    varParsing = false;
                    addChar = false;
                    if (token == 'cursor') {
                        tokens.push({
                            cursor: true
                        });
                    }
                    else if (token == 'line_selection') {
                        tokens.push({
                            line_selection: true
                        });
                    }
                    else {
                        var tokenSplit = token.split(':');
                        if (tokenSplit.length > 1) {
                            var tokenIndex = parseInt(tokenSplit[0]);
                            lastVariableIndex = Math.max(tokenIndex, lastVariableIndex);
                            tokens.push({
                                variable: {
                                    index: tokenIndex,
                                    name: tokenSplit[1]
                                }
                            });
                        }
                        else {
                            tokens.push({
                                variable: {
                                    index: ++lastVariableIndex,
                                    name: token
                                }
                            });
                        }
                    }
                    token = '';
                }
            }
            else {
                if (current == "$" && (i + 1) <= content.length) {
                    i++;
                    var next = content.charAt(i);
                    if (next == "{") {
                        varParsing = true;
                        addChar = false;
                        if (token != '') {
                            tokens.push(token);
                        }
                        token = '';
                    }
                }
            }
            if (addChar && last != "$") {
                token += current;
                last = current;
            }
            else {
                last = null;
            }
        }
    }
    if (token != '') {
        tokens.push(token);
    }
    return tokens;
}
function getMarkerChanged(cm, textChanged) {
    var markers = cm.getDoc().findMarksAt(textChanged.from);
    if (markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i];
            if (marker._templateVar) {
                return marker;
            }
        }
    }
    return null;
}
function onChange(cm, textChanged) {
    var state = getState(cm);
    if (!textChanged.origin || !state || state.updating) {
        return;
    }
    try {
        state.updating = true;
        var markerChanged = getMarkerChanged(cm, textChanged);
        if (markerChanged == null) {
            uninstall(cm);
        }
        else {
            var posChanged = markerChanged.find();
            var newContent = cm.getDoc().getRange(posChanged.from, posChanged.to);
            for (var i = 0; i < state.marked.length; i++) {
                var marker = state.marked[i];
                if (marker != markerChanged
                    && marker._templateVar == markerChanged._templateVar) {
                    var pos = marker.find();
                    cm.getDoc().replaceRange(newContent, pos.from, pos.to);
                }
            }
        }
    }
    finally {
        state.updating = false;
    }
}
function selectNextVariable(cm, exitOnEnd) {
    var state = cm._templateState;
    if (state.selectableMarkers.length > 0) {
        state.varIndex++;
        if (state.varIndex >= state.selectableMarkers.length) {
            if (exitOnEnd) {
                exit(cm);
                return;
            }
            state.varIndex = 0;
        }
        var marker = state.selectableMarkers[state.varIndex];
        var pos = marker.find();
        cm.setSelection(pos.from, pos.to);
        var templateVar = marker._templateVar;
        for (var i = 0; i < state.marked.length; i++) {
            var m = state.marked[i];
            if (m == marker) {
                m.className = "";
                m.startStyle = "";
                m.endStyle = "";
            }
            else {
                if (m._templateVar == marker._templateVar) {
                    m.className = "CodeMirror-templates-variable-selected";
                    m.startStyle = "";
                    m.endStyle = "";
                }
                else {
                    m.className = "CodeMirror-templates-variable";
                    m.startStyle = "CodeMirror-templates-variable-start";
                    m.endStyle = "CodeMirror-templates-variable-end";
                }
            }
        }
        cm.refresh();
    }
    else {
        exit(cm);
    }
}
function exit(cm) {
    var cursor = cm._templateState.cursor;
    if (cursor != null) {
        var cursorPos = cursor.find();
        if (cursorPos != null) {
            cm.setSelection(cursorPos, cursorPos);
        }
    }
    uninstall(cm);
}
function uninstall(cm) {
    var state = cm._templateState;
    for (var i = 0; i < state.marked.length; i++) {
        state.marked[i].clear();
    }
    if (state.cursor != null) {
        state.cursor.clear();
    }
    state.marked.length = 0;
    state.selectableMarkers.length = 0;
    cm.off("change", onChange);
    cm.removeKeyMap(ourMap);
    delete cm._templateState;
}
function getCompletions(cm, text) {
    var completions = [];
    var mode = cm.getDoc().getMode().name;
    var list = templatesMap[mode];
    if (list) {
        for (var i = 0; i < list.length; i++) {
            var template = list[i];
            if (startsWith(template.name, text)) {
                var label = template.name;
                if (template.description) {
                    label += '- ' + template.description;
                }
                var className = "CodeMirror-hint-template";
                if (template.className)
                    className = template.className;
                var completion = {
                    "className": className,
                    "text": label,
                    "template": template
                };
                completion.data = completion;
                completion.hint = function (cm, data, completion) {
                    completion.template.insert(cm, data);
                };
                completion.info = function (completion) {
                    var content = completion.template.content();
                    return content;
                };
                completions.push(completion);
            }
        }
    }
    return completions;
}
exports.getCompletions = getCompletions;
function addTemplates(templates) {
    var context = templates.context;
    if (context) {
        var list = templatesMap[context];
        if (!list) {
            list = [];
            templatesMap[context] = list;
        }
        templates.templates.forEach(function (template) {
            list.push(new Template(template));
        });
    }
}
exports.addTemplates = addTemplates;
var templates = {
    "name": "typescript",
    "context": "typescript", "templates": [
        {
            "name": "for",
            "description": "iterate over array",
            "template": "for (var ${2:index} = 0; ${index} < ${1:array}.length; ${index}++) {\n\t${line_selection}${cursor}\n}"
        },
        {
            "name": "for",
            "description": "iterate over array with temporary variable",
            "template": "for (var ${index} = 0; ${index} < ${array}.length; ${index}++) {\n\tvar ${array_element} = ${array}[${index}];\n\t${cursor}\n}"
        },
        {
            "name": "forin",
            "description": "iterate using for .. in",
            "template": "for (var ${iterable_element} in ${iterable}) {\n\t${cursor}\n}"
        },
        {
            "name": "forof",
            "description": "iterate using for .. of",
            "template": "for (var ${2:iterable_element} of ${1:iterable}) {\n\t${cursor}\n}"
        },
        { "name": "do", "description": "do while statement", "template": "do {\n\t${line_selection}${cursor}\n} while (${condition});" },
        { "name": "switch", "description": "switch case statement", "template": "switch (${key}) {\n\tcase ${value}:\n\t\t${cursor}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n}" },
        { "name": "if", "description": "if statement", "template": "if (${condition}) {\n\t${line_selection}${cursor}\n}" },
        { "name": "ifelse", "description": "if else statement", "template": "if (${condition}) {\n\t${cursor}\n} else {\n\t\n}" },
        { "name": "elseif", "description": "else if block", "template": "else if (${condition}) {\n\t${cursor}\n}" },
        { "name": "else", "description": "else block", "template": "else {\n\t${cursor}\n}" },
        { "name": "try", "description": "try catch block", "template": "try {\n\t${line_selection}${cursor}\n} catch (e) {\n\t// ${todo}: handle exception\n}" },
        { "name": "catch", "description": "catch block", "template": "catch (e) {\n\t${cursor}// ${todo}: handle exception\n}" },
        { "name": "function", "description": "function", "template": "function ${name}(${}) {\n\t${cursor}\n}" },
        { "name": "function", "description": "anonymous function", "template": "function (${}) {\n\t${cursor}\n}" },
        { "name": "new", "description": "create new object", "template": "var ${name} = new ${type}(${arguments});" },
        { "name": "lazy", "description": "lazy creation", "template": "if (${name:var} == null) {\n\t${name} = new ${type}(${arguments});\n\t${cursor}\n}\n\nreturn ${name};" },
        { "name": "<code>", "description": "<code></code>", "template": "<code>${word_selection}${}</code>${cursor}" },
        { "name": "null", "description": "<code>null</code>", "template": "<code>null</code>" },
        { "name": "true", "description": "<code>true</code>", "template": "<code>true</code>" },
        { "name": "false", "description": "<code>false</code>", "template": "<code>false</code>" },
        { "name": "<pre>", "description": "<pre></pre>", "template": "<pre>${word_selection}${}</pre>${cursor}" },
        { "name": "<b>", "description": "<b></b>", "template": "<b>${word_selection}${}</b>${cursor}" },
        { "name": "<i>", "description": "<i></i>", "template": "<i>${word_selection}${}</i>${cursor}" },
        { "name": "@author", "description": "author name", "template": "@author ${user}" },
        { "name": "while", "description": "while loop with condition", "template": "while (${condition}) {\n\t${line_selection}${cursor}\n}" }
    ]
};
addTemplates(templates);
