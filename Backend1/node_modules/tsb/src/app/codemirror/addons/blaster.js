"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var CodeMirror = require('codemirror');
var ui = require('../../ui');
var React = require("react");
var onresize = require('onresize');
var utils = require("../../../common/utils");
var Effect;
(function (Effect) {
    Effect[Effect["Add"] = 1] = "Add";
    Effect[Effect["Delete"] = 2] = "Delete";
})(Effect || (Effect = {}));
var Blaster = (function (_super) {
    __extends(Blaster, _super);
    function Blaster() {
        var _this = this;
        _super.apply(this, arguments);
        this.canvas = function () { return _this.refs['canvas']; };
        this.initCanvas = function (cm) {
            var canvas = _this.canvas();
            _this.ctx = canvas.getContext('2d');
            canvas.style.position = 'absolute';
            canvas.style.width = "100%";
            canvas.style.height = "100%";
            canvas.style.zIndex = '1';
            canvas.style.pointerEvents = 'none';
            var measureCanvas = function () {
                var parent = _this.getParentDomNode();
                _this.canvas().width = parent.clientWidth;
                _this.canvas().height = parent.clientHeight;
            };
            _this.disposible.add(onresize.on(measureCanvas));
            cm.refresh = utils.intercepted({ context: cm, orig: cm.refresh, intercept: measureCanvas });
            measureCanvas();
        };
        this.lastTime = 0;
        this.shakeTime = 0;
        this.shakeTimeMax = 0;
        this.shakeIntensity = 5;
        this.loop = function () {
            if (_this.isUnmounted)
                return;
            requestAnimationFrame(_this.loop);
            if (!enabled) {
                return;
            }
            _this.ctx.clearRect(0, 0, _this.canvas().width, _this.canvas().height);
            _this.drawShake();
            _this.drawParticles();
        };
        this.particles = [];
        this.drawParticles = function (timeDelta) {
            if (!_this.particles.length)
                return;
            for (var _i = 0, _a = _this.particles; _i < _a.length; _i++) {
                var particle = _a[_i];
                if (particle.effect === Effect.Add) {
                    _this.effect1(particle);
                }
                else if (particle.effect === Effect.Delete) {
                    _this.effect2(particle);
                }
            }
            _this.particles = _this.particles.filter(function (particle) { return particle && particle.alpha > 0.01 && particle.size > 0.5; });
        };
        this.PARTICLE_GRAVITY = 0.08;
        this.PARTICLE_ALPHA_FADEOUT = 0.96;
        this.throttledShake = utils.throttle(function (time) {
            _this.shakeTime = _this.shakeTimeMax = time;
        }, 100);
        this.PARTICLE_NUM_RANGE = { min: 5, max: 10 };
        this.throttledSpawnParticles = utils.throttle(function (effect) {
            var cm = _this.props.cm;
            var cursorPos = cm.getDoc().getCursor();
            var posForNode = cm.cursorCoords(cursorPos, 'window');
            var node = document.elementFromPoint(posForNode.left - 5, posForNode.top + 5);
            var color = getRGBComponents(node);
            var numParticles = random(_this.PARTICLE_NUM_RANGE.min, _this.PARTICLE_NUM_RANGE.max);
            var pos = cm.cursorCoords(cursorPos, 'page');
            for (var i = 0; i < numParticles; i++) {
                _this.particles.push(_this.createParticle(pos.left, pos.top - 25, color, effect));
            }
        }, 100);
        this.PARTICLE_VELOCITY_RANGE = {
            x: [-1, 1],
            y: [-3.5, -1.5]
        };
        this.handleChange = function (doc, change) {
            if (!enabled) {
                return;
            }
            _this.throttledShake(0.3);
            if (change.text.join('')) {
                _this.throttledSpawnParticles(Effect.Add);
            }
            else {
                _this.throttledSpawnParticles(Effect.Delete);
            }
        };
    }
    Blaster.prototype.render = function () {
        var style = this.props.cm ? {} : { display: 'none' };
        return React.createElement("canvas", {style: style, ref: "canvas"});
    };
    Blaster.prototype.componentWillReceiveProps = function (props) {
        if (!this.props.cm && props.cm) {
            props.cm.on('change', this.handleChange);
            this.initCanvas(props.cm);
            this.loop();
        }
    };
    Blaster.prototype.componentWillUnmount = function () {
        _super.prototype.componentWillUnmount.call(this);
        this.props.cm.off('change', this.handleChange);
    };
    Blaster.prototype.drawShake = function () {
        var current_time = new Date().getTime();
        var last_time;
        if (!this.lastTime)
            last_time = current_time;
        var dt = (current_time - this.lastTime) / 1000;
        this.lastTime = current_time;
        if (this.shakeTime > 0) {
            this.shakeTime -= dt;
            var magnitude = (this.shakeTime / this.shakeTimeMax) * this.shakeIntensity;
            var shakeX = random(-magnitude, magnitude);
            var shakeY = random(-magnitude, magnitude);
            this.props.cm.getWrapperElement().style.transform = 'translate(' + shakeX + 'px,' + shakeY + 'px)';
        }
    };
    Blaster.prototype.effect1 = function (particle) {
        particle.vy += this.PARTICLE_GRAVITY;
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.alpha *= this.PARTICLE_ALPHA_FADEOUT;
        this.ctx.fillStyle = 'rgba(' + particle.color[0] + ',' + particle.color[1] + ',' + particle.color[2] + ',' + particle.alpha + ')';
        this.ctx.fillRect(Math.round(particle.x - 1), Math.round(particle.y - 1), particle.size, particle.size);
    };
    Blaster.prototype.effect2 = function (particle) {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vx *= particle.drag;
        particle.vy *= particle.drag;
        particle.theta += random(-0.5, 0.5);
        particle.vx += Math.sin(particle.theta) * 0.1;
        particle.vy += Math.cos(particle.theta) * 0.1;
        particle.size *= 0.96;
        this.ctx.fillStyle = 'rgba(' + particle.color[0] + ',' + particle.color[1] + ',' + particle.color[2] + ',' + particle.alpha + ')';
        this.ctx.beginPath();
        this.ctx.arc(particle.x - particle.size / 2, particle.y - particle.size / 2, particle.size, 0, 2 * Math.PI);
        this.ctx.fill();
    };
    Blaster.prototype.createParticle = function (x, y, color, effect) {
        var p = {
            x: x,
            y: y + 10,
            alpha: 1,
            color: color,
            effect: effect,
            drag: 0,
            wander: 0,
            theta: 0,
            size: 0,
            vx: 0,
            vy: 0,
        };
        if (effect == Effect.Add) {
            p.size = random(2, 4);
            p.vx = this.PARTICLE_VELOCITY_RANGE.x[0] + Math.random() *
                (this.PARTICLE_VELOCITY_RANGE.x[1] - this.PARTICLE_VELOCITY_RANGE.x[0]);
            p.vy = this.PARTICLE_VELOCITY_RANGE.y[0] + Math.random() *
                (this.PARTICLE_VELOCITY_RANGE.y[1] - this.PARTICLE_VELOCITY_RANGE.y[0]);
        }
        else if (effect == Effect.Delete) {
            p.size = random(2, 8);
            p.drag = 0.92;
            p.vx = random(-3, 3);
            p.vy = random(-3, 3);
            p.wander = 0.15;
            p.theta = random(0, 360) * Math.PI / 180;
        }
        return p;
    };
    return Blaster;
})(ui.BaseComponent);
exports.Blaster = Blaster;
function random(min, max) {
    if (!max) {
        max = min;
        min = 0;
    }
    return min + ~~(Math.random() * (max - min + 1));
}
function getRGBComponents(node) {
    if (node) {
        try {
            var color = getComputedStyle(node).color;
            return color.match(/(\d+), (\d+), (\d+)/).slice(1);
        }
        catch (e) {
            return ['255', '255', '255'];
        }
    }
    else {
        return ['255', '255', '255'];
    }
}
var enabled = false;
var commands = require("../../commands/commands");
CodeMirror.commands[commands.additionalEditorCommands.toggleBlaster] = function (editor) {
    enabled = !enabled;
};
