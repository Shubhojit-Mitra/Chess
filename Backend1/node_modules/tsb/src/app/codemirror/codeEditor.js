"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var CodeMirror = require('codemirror');
require('codemirror/lib/codemirror.css');
require('codemirror/theme/monokai.css');
require('codemirror/addon/comment/comment');
require('codemirror/addon/fold/foldcode');
require('codemirror/addon/fold/foldgutter');
require('codemirror/addon/fold/brace-fold');
require('codemirror/addon/fold/xml-fold');
require('codemirror/addon/fold/markdown-fold');
require('codemirror/addon/fold/comment-fold');
require('codemirror/addon/fold/foldgutter.css');
require('codemirror/addon/selection/active-line');
require('codemirror/addon/edit/matchbrackets');
require('codemirror/addon/edit/closebrackets');
require('codemirror/addon/edit/matchtags');
require('codemirror/addon/search/match-highlighter');
require('./addons/text-hover');
require('./addons/text-hover.css');
require('./addons/jumpy');
var blaster = require('./addons/blaster');
require('./addons/templates');
require('./addons/templates.css');
require('./override.css');
var autocomplete = require('./addons/autocomplete');
var linter = require('./addons/linter');
var search = require("./addons/search");
var typescriptMode = require("./mode/typescript");
typescriptMode.register();
var docCache = require("./mode/docCache");
var React = require('react');
var ReactDOM = require('react-dom');
var onresize = require('onresize');
var csx = require("csx");
var ui = require("../ui");
var socketClient_1 = require("../../socket/socketClient");
var escape = require("escape-html");
var doctor = require("./addons/doctor");
var state = require("../state/state");
var cursorLocation = require("../cursorHistory");
var CodeEditor = (function (_super) {
    __extends(CodeEditor, _super);
    function CodeEditor(props) {
        var _this = this;
        _super.call(this, props);
        this.focus = function () {
            if (_this.codeMirror) {
                _this.codeMirror.focus();
                _this.handleCursorActivity();
                _this.refresh();
                setTimeout(_this.refresh, 500);
            }
        };
        this.gotoPosition = function (position) {
            if (_this.codeMirror) {
                _this.codeMirror.getDoc().setCursor(position);
                _this.codeMirror.focus();
            }
        };
        this.refresh = function () {
            if (_this.codeMirror) {
                _this.codeMirror.refresh();
            }
        };
        this.focusChanged = function (focused) {
            _this.setState({
                isFocused: focused
            });
            _this.props.onFocusChange && _this.props.onFocusChange(focused);
        };
        this.search = function (options) {
            search.commands.search(_this.codeMirror, _this.findOptionsToQueryRegex(options));
        };
        this.hideSearch = function () {
            search.commands.hideSearch(_this.codeMirror);
        };
        this.findNext = function (options) {
            search.commands.findNext(_this.codeMirror, _this.findOptionsToQueryRegex(options));
        };
        this.findPrevious = function (options) {
            search.commands.findPrevious(_this.codeMirror, _this.findOptionsToQueryRegex(options));
        };
        this.replaceNext = function (newText) {
            search.commands.replaceNext(_this.codeMirror, newText);
        };
        this.replaceAll = function (newText) {
            search.commands.replaceAll(_this.codeMirror, newText);
        };
        this.handleCursorActivity = function () {
            var cursor = _this.codeMirror.getDoc().getCursor();
            cursorLocation.addEntry(cursor);
        };
        this.state = {
            isFocused: false
        };
    }
    CodeEditor.prototype.componentDidMount = function () {
        var _this = this;
        var options = {
            filePath: this.props.filePath,
            readOnly: this.props.readOnly,
            lineNumbers: true,
            keyMap: 'sublime',
            theme: 'monokai',
            indentUnit: 4,
            gutters: ["CodeMirror-linenumbers"],
            styleActiveLine: true,
            matchBrackets: true,
            highlightSelectionMatches: { showToken: /\w/ },
            autoCloseBrackets: true,
            matchTags: { bothTags: true },
            textHover: function (cm, data, e) {
                if (data && data.pos) {
                    return _this.getQuickInfo(data.pos);
                }
            },
            lineWrapping: true,
        };
        autocomplete.setupOptions(options, this.props.filePath);
        options.foldGutter = true;
        options.gutters.push("CodeMirror-foldgutter");
        linter.setupOptions(options, this.props.filePath);
        this.disposible.add(socketClient_1.cast.errorsUpdated.on(function () { return _this.codeMirror && _this.codeMirror.performLint(); }));
        setTimeout(function () { return _this.codeMirror && _this.codeMirror.performLint(); }, 1000);
        var textareaNode = ReactDOM.findDOMNode(this.refs.textarea);
        this.codeMirror = CodeMirror.fromTextArea(textareaNode, options);
        this.codeMirror.filePath = this.props.filePath;
        this.codeMirror.on('focus', this.focusChanged.bind(this, true));
        this.codeMirror.on('blur', this.focusChanged.bind(this, false));
        autocomplete.setupCodeMirror(this.codeMirror);
        this.disposible.add(onresize.on(function () { return _this.refresh(); }));
        if (!this.props.readOnly) {
            this.codeMirror.on('cursorActivity', this.handleCursorActivity);
            this.disposible.add({ dispose: function () { return _this.codeMirror.off('cursorActivity', _this.handleCursorActivity); } });
        }
        docCache.getLinkedDoc(this.props.filePath).then(function (doc) {
            _this.codeMirror.swapDoc(doc);
            if (_this.props.preview) {
                var preview = _this.props.preview;
                var from = doc.posFromIndex(preview.start);
                var to = doc.posFromIndex(preview.start + preview.length);
                doc.setCursor(from);
                _this.codeMirror.scrollIntoView(from);
            }
        });
    };
    CodeEditor.prototype.componentWillUnmount = function () {
        if (this.codeMirror) {
            this.codeMirror.toTextArea();
            this.codeMirror.getDoc().cm = null;
        }
        this.disposible.dispose();
    };
    CodeEditor.prototype.getQuickInfo = function (pos) {
        if (state.inActiveProject(this.props.filePath)) {
            return socketClient_1.server.quickInfo({ filePath: this.props.filePath, position: this.codeMirror.getDoc().indexFromPos(pos) }).then(function (resp) {
                if (!resp.valid)
                    return;
                var message = "<b>" + escape(resp.name) + "</b>";
                if (resp.comment) {
                    message = message + ("<br/><i>" + escape(resp.comment).replace(/(?:\r\n|\r|\n)/g, '<br />') + "</i>");
                }
                var div = document.createElement('div');
                div.innerHTML = message;
                return div;
            });
        }
    };
    CodeEditor.prototype.getCodeMirror = function () {
        return this.codeMirror;
    };
    CodeEditor.prototype.getValue = function () {
        return this.codeMirror.getDoc().getValue();
    };
    CodeEditor.prototype.findOptionsToQueryRegex = function (options) {
        var str = options.query;
        var query;
        var defaultQuery = /x^/;
        if (!options.isRegex) {
            str = str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        }
        if (options.isFullWord) {
            str = "\\b" + str + "\\b";
        }
        try {
            query = new RegExp(str, options.isCaseSensitive ? "g" : "gi");
        }
        catch (e) {
            query = defaultQuery;
        }
        if (query.test("")) {
            query = defaultQuery;
        }
        return query;
    };
    CodeEditor.prototype.render = function () {
        var className = 'ReactCodeMirror';
        if (this.state.isFocused) {
            className += ' ReactCodeMirror--focused';
        }
        return (React.createElement("div", {className: className, style: csx.extend(csx.vertical, csx.flex, { position: 'relative' })}, !this.props.readOnly && React.createElement(doctor.Doctor, {cm: this.codeMirror, filePath: this.props.filePath}), !this.props.readOnly && React.createElement(blaster.Blaster, {cm: this.codeMirror}), React.createElement("textarea", {ref: "textarea", name: this.props.filePath, autoComplete: false})));
    };
    return CodeEditor;
})(ui.BaseComponent);
exports.CodeEditor = CodeEditor;
"\n<style type=\"text/css\">\n      .breakpoints {width: .8em;}\n      .breakpoint { color: #822; }\n      .CodeMirror {border: 1px solid #aaa;}\n    </style>\n";
"\nvar editor = CodeMirror.fromTextArea(document.getElementById(\"code\"), {\n  lineNumbers: true,\n  gutters: [\"CodeMirror-linenumbers\", \"breakpoints\"]\n});\neditor.on(\"gutterClick\", function(cm, n) {\n  var info = cm.lineInfo(n);\n  cm.setGutterMarker(n, \"breakpoints\", info.gutterMarkers ? null : makeMarker());\n});\nfunction makeMarker() {\n  var marker = document.createElement(\"div\");\n  marker.style.color = \"#822\";\n  marker.innerHTML = \"\u25CF\";\n  return marker;\n}\n";
