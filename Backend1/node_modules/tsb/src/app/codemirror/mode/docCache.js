"use strict";
var CodeMirror = require("codemirror");
var socketClient_1 = require("../../../socket/socketClient");
var utils = require("../../../common/utils");
var classifierCache = require("./classifierCache");
require('codemirror/mode/javascript/javascript');
require('codemirror/mode/xml/xml');
require('codemirror/mode/css/css');
require('codemirror/mode/sass/sass');
require('codemirror/mode/dart/dart');
require('codemirror/mode/haml/haml');
require('codemirror/mode/gfm/gfm');
require('codemirror/mode/coffeescript/coffeescript');
var supportedModesMap = {
    js: 'javascript', json: 'javascript',
    xml: 'text/html', html: 'text/html',
    css: 'css', less: 'text/x-less', gss: 'text/x-gss',
    sass: 'sass',
    dart: 'dart',
    haml: 'haml',
    markdown: 'gfm', md: 'gfm',
    coffee: 'coffeescript', coffeescript: 'coffeescript',
};
var docByFilePathPromised = {};
function getLinkedDoc(filePath) {
    return getOrCreateDoc(filePath)
        .then(function (doc) {
        setTimeout(function () {
            var markForRemove = [];
            doc.iterLinkedDocs(function (linked) {
                if (!linked.getEditor()) {
                    markForRemove.push(linked);
                }
            });
            markForRemove.forEach(function (linked) { doc.unlinkDoc(linked); });
        }, 2000);
        return doc.linkedDoc({ sharedHist: true });
    });
}
exports.getLinkedDoc = getLinkedDoc;
function getOrCreateDoc(filePath) {
    if (docByFilePathPromised[filePath]) {
        return docByFilePathPromised[filePath];
    }
    else {
        return docByFilePathPromised[filePath] = socketClient_1.server.openFile({ filePath: filePath }).then(function (res) {
            var ext = utils.getExt(filePath);
            var isTsFile = utils.isTsFile(filePath);
            var mode = isTsFile
                ? 'typescript'
                : supportedModesMap[ext]
                    ? supportedModesMap[ext]
                    : 'text';
            var sourceId = utils.createId();
            if (isTsFile) {
                classifierCache.addFile(filePath, res.contents);
            }
            var doc = new CodeMirror.Doc(res.contents, mode);
            doc.filePath = filePath;
            doc.rootDoc = true;
            doc.on('change', function (doc, change) {
                if (change.origin == sourceId) {
                    return;
                }
                var codeEdit = {
                    from: { line: change.from.line, ch: change.from.ch },
                    to: { line: change.to.line, ch: change.to.ch },
                    newText: change.text.join('\n'),
                    sourceId: sourceId
                };
                if (isTsFile) {
                    classifierCache.editFile(filePath, codeEdit);
                }
                socketClient_1.server.editFile({ filePath: filePath, edit: codeEdit });
            });
            socketClient_1.cast.didEdit.on(function (res) {
                var codeEdit = res.edit;
                if (res.filePath == filePath && codeEdit.sourceId !== sourceId) {
                    if (isTsFile) {
                        classifierCache.editFile(filePath, codeEdit);
                    }
                    doc.replaceRange(codeEdit.newText, codeEdit.from, codeEdit.to, sourceId);
                }
            });
            socketClient_1.cast.savedFileChangedOnDisk.on(function (res) {
                if (res.filePath == filePath
                    && doc.getValue() !== res.contents) {
                    if (isTsFile) {
                        classifierCache.setContents(filePath, res.contents);
                    }
                    var cursor = doc.getCursor();
                    var lastLine = doc.lastLine();
                    var lastCh = doc.getLine(lastLine).length;
                    doc.replaceRange(res.contents, { line: 0, ch: 0 }, { line: lastLine, ch: lastCh }, sourceId);
                    doc.setCursor(cursor);
                }
            });
            return doc;
        });
    }
}
function getOrCreateDocs(filePaths) {
    var promises = filePaths.map(function (fp) { return getOrCreateDoc(fp); });
    return Promise.all(promises).then(function (docs) {
        var res = {};
        docs.forEach(function (doc) { return res[doc.filePath] = doc; });
        return res;
    });
}
function applyRefactoringsToTsDocs(refactorings) {
    var filePaths = Object.keys(refactorings);
    getOrCreateDocs(filePaths).then(function (docsByFilePath) {
        filePaths.forEach(function (fp) {
            var doc = docsByFilePath[fp];
            var changes = refactorings[fp];
            for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
                var change = changes_1[_i];
                var from = classifierCache.getLineAndCharacterOfPosition(fp, change.span.start);
                var to = classifierCache.getLineAndCharacterOfPosition(fp, change.span.start + change.span.length);
                doc.replaceRange(change.newText, from, to, '*refactor');
            }
        });
    });
}
exports.applyRefactoringsToTsDocs = applyRefactoringsToTsDocs;
