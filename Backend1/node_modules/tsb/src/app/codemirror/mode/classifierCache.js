"use strict";
var ts = require('ntypescript');
var lsh = require("../server/languageServiceHost");
var languageServiceHost = new lsh.LSHost();
var languageService = ts.createLanguageService(languageServiceHost);
function addFile(filePath, contents) {
    languageServiceHost.addScript(filePath, contents);
}
exports.addFile = addFile;
function editFile(filePath, codeEdit) {
    var from = languageServiceHost.getPositionOfLineAndCharacter(filePath, codeEdit.from.line, codeEdit.from.ch);
    var to = languageServiceHost.getPositionOfLineAndCharacter(filePath, codeEdit.to.line, codeEdit.to.ch);
    languageServiceHost.editScript(filePath, from, to, codeEdit.newText);
}
exports.editFile = editFile;
function setContents(filePath, contents) {
    languageServiceHost.setContents(filePath, contents);
}
exports.setContents = setContents;
function getLineAndCharacterOfPosition(filePath, pos) {
    return languageServiceHost.getLineAndCharacterOfPosition(filePath, pos);
}
exports.getLineAndCharacterOfPosition = getLineAndCharacterOfPosition;
function getClassificationsForLine(filePath, lineStart, string) {
    var lineLength = string.length;
    var encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });
    var classifications = unencodeClassifications(encodedClassifications);
    var lastStartSet = false;
    var lastStart = 0;
    classifications = classifications
        .map(function (c, i) {
        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {
            return null;
        }
        if (c.textSpan.start > (lineStart + lineLength)) {
            return null;
        }
        if (c.textSpan.start < lineStart) {
            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;
            c.textSpan.start = lineStart;
        }
        if ((c.textSpan.start + c.textSpan.length) > (lineStart + lineLength)) {
            c.textSpan.length = (lineStart + lineLength) - (c.textSpan.start);
        }
        if (!lastStartSet) {
            lastStartSet = true;
            lastStart = c.textSpan.start;
        }
        else {
            if (c.textSpan.start == lastStart) {
                return null;
            }
        }
        return c;
    })
        .filter(function (c) { return !!c; });
    classifications.forEach(function (c) {
        c.startInLine = c.textSpan.start - lineStart;
        c.string = string.substr(c.startInLine, c.textSpan.length);
    });
    return classifications;
}
exports.getClassificationsForLine = getClassificationsForLine;
function getIndentationAtPosition(filePath, lineStart, options) {
    return languageService.getIndentationAtPosition(filePath, lineStart, options);
}
exports.getIndentationAtPosition = getIndentationAtPosition;
function unencodeClassifications(classifications) {
    var dense = classifications.spans;
    var result = [];
    var expectedStart = 0;
    for (var i = 0, n = dense.length; i < n; i += 3) {
        if (dense[i] > expectedStart) {
            result.push({
                textSpan: ts.createTextSpan(expectedStart, dense[i] - expectedStart),
                classificationType: ts.ClassificationType.whiteSpace,
                classificationTypeName: ts.ClassificationTypeNames.whiteSpace,
            });
        }
        result.push({
            textSpan: ts.createTextSpan(dense[i], dense[i + 1]),
            classificationType: dense[i + 2],
            classificationTypeName: getClassificationTypeName(dense[i + 2]),
        });
        expectedStart = dense[i] + dense[i + 1];
    }
    return result;
}
var ClassificationType = ts.ClassificationType;
var ClassificationTypeNames = ts.ClassificationTypeNames;
function getClassificationTypeName(type) {
    switch (type) {
        case ClassificationType.comment: return ClassificationTypeNames.comment;
        case ClassificationType.identifier: return ClassificationTypeNames.identifier;
        case ClassificationType.keyword: return ClassificationTypeNames.keyword;
        case ClassificationType.numericLiteral: return ClassificationTypeNames.numericLiteral;
        case ClassificationType.operator: return ClassificationTypeNames.operator;
        case ClassificationType.stringLiteral: return ClassificationTypeNames.stringLiteral;
        case ClassificationType.whiteSpace: return ClassificationTypeNames.whiteSpace;
        case ClassificationType.text: return ClassificationTypeNames.text;
        case ClassificationType.punctuation: return ClassificationTypeNames.punctuation;
        case ClassificationType.className: return ClassificationTypeNames.className;
        case ClassificationType.enumName: return ClassificationTypeNames.enumName;
        case ClassificationType.interfaceName: return ClassificationTypeNames.interfaceName;
        case ClassificationType.moduleName: return ClassificationTypeNames.moduleName;
        case ClassificationType.typeParameterName: return ClassificationTypeNames.typeParameterName;
        case ClassificationType.typeAliasName: return ClassificationTypeNames.typeAliasName;
        case ClassificationType.parameterName: return ClassificationTypeNames.parameterName;
        case ClassificationType.docCommentTagName: return ClassificationTypeNames.docCommentTagName;
        case ClassificationType.jsxOpenTagName: return ClassificationTypeNames.jsxOpenTagName;
        case ClassificationType.jsxCloseTagName: return ClassificationTypeNames.jsxCloseTagName;
        case ClassificationType.jsxSelfClosingTagName: return ClassificationTypeNames.jsxSelfClosingTagName;
    }
}
