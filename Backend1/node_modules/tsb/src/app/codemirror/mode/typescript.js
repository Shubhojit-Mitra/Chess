"use strict";
var ts = require('ntypescript');
var classifierCache = require("./classifierCache");
function getStyleForToken(token, textBefore) {
    var ClassificationType = ts.ClassificationType;
    switch (token.classificationType) {
        case ClassificationType.numericLiteral:
            return 'number';
        case ClassificationType.stringLiteral:
            return 'string';
        case ClassificationType.regularExpressionLiteral:
            return 'string-2';
        case ClassificationType.operator:
            return 'operator';
        case ClassificationType.comment:
            return 'comment';
        case ClassificationType.className:
        case ClassificationType.enumName:
        case ClassificationType.interfaceName:
        case ClassificationType.moduleName:
        case ClassificationType.typeParameterName:
        case ClassificationType.typeAliasName:
            return 'variable-2';
        case ClassificationType.keyword:
            switch (token.string) {
                case 'string':
                case 'number':
                case 'void':
                case 'bool':
                case 'boolean':
                    return 'variable-2';
                case 'static':
                case 'public':
                case 'private':
                case 'get':
                case 'set':
                    return 'qualifier';
                case 'function':
                case 'var':
                case 'let':
                case 'const':
                    return 'def';
                default:
                    return 'keyword';
            }
        case ClassificationType.identifier:
            if (token.string.charAt(0).toLowerCase() !== token.string.charAt(0)) {
                return 'variable-2';
            }
            else {
                return 'variable';
            }
        case ClassificationType.parameterName:
            return 'def';
        case ClassificationType.punctuation:
            if (token.string == '>' || token.string == '<' || token.string == '/>') {
                return 'tag.bracket';
            }
            return 'bracket';
        case ClassificationType.jsxOpenTagName:
        case ClassificationType.jsxCloseTagName:
        case ClassificationType.jsxSelfClosingTagName:
            return 'tag';
        case ClassificationType.whiteSpace:
        default:
            return null;
    }
}
function getClassificationMap(classifications) {
    var classificationMap = {};
    for (var i = 0, l = classifications.length; i < l; i++) {
        var classification = classifications[i];
        classificationMap[classification.startInLine] = classification;
    }
    return classificationMap;
}
function typeScriptModeFactory(options, spec) {
    return {
        lineComment: '//',
        blockCommentStart: '/*',
        blockCommentEnd: '*/',
        electricChars: ':{}[]()',
        startState: function () {
            return {
                classificationMap: {},
                lineNumber: 0,
                lineStartIndex: 0,
            };
        },
        copyState: function (lineDescriptor) {
            return {
                classificationMap: lineDescriptor.classificationMap,
                lineNumber: lineDescriptor.lineNumber,
                lineStartIndex: lineDescriptor.lineStartIndex,
            };
        },
        blankLine: function (lineDescriptor) {
            lineDescriptor.lineNumber++;
            lineDescriptor.lineStartIndex++;
        },
        token: function (stream, lineDescriptor) {
            if (stream.sol()) {
                var classifications = classifierCache.getClassificationsForLine(options.filePath, lineDescriptor.lineStartIndex, stream.string);
                var classificationMap = getClassificationMap(classifications);
                lineDescriptor.classificationMap = classificationMap;
                lineDescriptor.lineNumber++;
                lineDescriptor.lineStartIndex = lineDescriptor.lineStartIndex + stream.string.length + 1;
            }
            var classifiedSpan = lineDescriptor.classificationMap[stream.pos];
            if (classifiedSpan) {
                var textBefore = stream.string.substr(0, stream.pos);
                for (var i = 0; i < classifiedSpan.string.length; i++) {
                    stream.next();
                }
                return getStyleForToken(classifiedSpan, textBefore);
            }
            else {
                stream.skipToEnd();
            }
            return null;
        },
        indent: function (lineDescriptor, textAfter) {
            var indentOptions = {
                IndentSize: options.indentUnit,
                TabSize: options.tabSize,
                NewLineCharacter: '\n',
                IndentStyle: ts.IndentStyle.Smart,
                ConvertTabsToSpaces: !options.indentWithTabs
            };
            var indent = classifierCache.getIndentationAtPosition(options.filePath, lineDescriptor.lineStartIndex, indentOptions);
            if (textAfter.trim() == '}') {
                indent -= options.indentUnit;
            }
            return indent;
        }
    };
}
var CodeMirror = require('codemirror');
function register() {
    CodeMirror.defineMode('typescript', typeScriptModeFactory);
}
exports.register = register;
