"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
exports.anycastMessageName = 'anycast';
__export(require("../common/events"));
function createId() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
var RequesterResponder = (function () {
    function RequesterResponder() {
        var _this = this;
        this.currentListeners = {};
        this.currentLastOfType = {};
        this.pendingRequests = [];
        this.pendingRequestsChanged = function (pending) { return null; };
        this.sendToServerHeart = function (data, message) {
            if (!_this.getSocket()) {
                console.log('SEND ERR: no server when you tried to send :', message);
                return Promise.reject(new Error("No socket active to recieve message: " + message));
            }
            if (!_this.currentListeners[message])
                _this.currentListeners[message] = {};
            var id = createId();
            var defer = Promise.defer();
            _this.currentListeners[message][id] = defer;
            _this.pendingRequests.push(message);
            _this.pendingRequestsChanged(_this.pendingRequests);
            _this.getSocket().emit('message', { message: message, id: id, data: data, isRequest: true });
            return defer.promise;
        };
        this.responders = {};
        this.processRequest = function (m) {
            var parsed = m;
            if (!parsed.message || !_this.responders[parsed.message]) {
                return;
            }
            var message = parsed.message;
            var responsePromise;
            try {
                responsePromise = _this.responders[message](parsed.data, _this.client);
            }
            catch (err) {
                responsePromise = Promise.reject({ method: message, message: err.message, stack: err.stack, details: err.details || {} });
            }
            responsePromise
                .then(function (response) {
                _this.getSocket().emit('message', {
                    message: message,
                    id: parsed.id,
                    data: response,
                    error: null,
                    isRequest: false
                });
            })
                .catch(function (error) {
                _this.getSocket().emit('message', {
                    message: message,
                    id: parsed.id,
                    data: null,
                    error: error,
                    isRequest: false
                });
            });
        };
    }
    RequesterResponder.prototype.startListening = function () {
        var _this = this;
        try {
            if (!this.getSocket()) {
                console.log('You started listening without a socket!');
                return;
            }
            var socket = this.getSocket();
            socket.on('error', function (err) {
            });
            socket.on('message', function (message) {
                if (message.isRequest) {
                    _this.processRequest(message);
                }
                else {
                    _this.processResponse(message);
                }
            });
        }
        catch (err) {
            console.log('Socket : terminal error in listening', err);
        }
    };
    RequesterResponder.prototype.processResponse = function (m) {
        var parsed = m;
        this.pendingRequests.shift();
        this.pendingRequestsChanged(this.pendingRequests.slice());
        if (!parsed.message || !parsed.id) {
            console.log('SERVER ERR: Invalid JSON data from server:', m);
        }
        else if (!this.currentListeners[parsed.message] || !this.currentListeners[parsed.message][parsed.id]) {
            console.log('SERVER ERR: No one was listening:', parsed.message, parsed.data);
        }
        else {
            if (parsed.error) {
                this.currentListeners[parsed.message][parsed.id].reject(parsed.error);
                console.log(parsed.error);
                console.log(parsed.error.stack);
            }
            else {
                this.currentListeners[parsed.message][parsed.id].resolve(parsed.data);
            }
            delete this.currentListeners[parsed.message][parsed.id];
            if (this.currentLastOfType[parsed.message]) {
                var last = this.currentLastOfType[parsed.message];
                delete this.currentLastOfType[parsed.message];
                var lastPromise = this.sendToServerHeart(last.data, parsed.message);
                lastPromise.then(function (res) { return last.defer.resolve(res); }, function (rej) { return last.defer.reject(rej); });
            }
        }
    };
    RequesterResponder.prototype.sendAllToSocket = function (contract) {
        var _this = this;
        var toret = {};
        Object.keys(contract).forEach(function (key) {
            toret[key] = _this.sendToSocket(contract[key], key);
        });
        return toret;
    };
    RequesterResponder.prototype.sendToSocket = function (func, name) {
        var _this = this;
        var message = name;
        return function (data) { return _this.sendToServerHeart(data, message); };
    };
    RequesterResponder.prototype.sendToSocketOnlyLast = function (func, defaultResponse, name) {
        var _this = this;
        return function (data) {
            var message = name;
            if (!_this.getSocket()) {
                console.log('SEND ERR: no socket when you tried to send :', message);
                return Promise.reject(new Error("No worker active to recieve message: " + message));
            }
            if (!Object.keys(_this.currentListeners[message] || {}).length) {
                return _this.sendToServerHeart(data, message);
            }
            else {
                if (_this.currentLastOfType[message]) {
                    _this.currentLastOfType[message].defer.resolve(defaultResponse);
                }
                var defer = Promise.defer();
                _this.currentLastOfType[message] = {
                    data: data,
                    defer: defer
                };
                return defer.promise;
            }
        };
    };
    RequesterResponder.prototype.addToResponders = function (func, name) {
        this.responders[name] = func;
    };
    RequesterResponder.prototype.registerAllFunctionsExportedFromAsResponders = function (aModule) {
        var _this = this;
        Object.keys(aModule)
            .filter(function (funcName) { return typeof aModule[funcName] == 'function'; })
            .forEach(function (funcName) { return _this.addToResponders(aModule[funcName], funcName); });
    };
    return RequesterResponder;
})();
exports.RequesterResponder = RequesterResponder;
